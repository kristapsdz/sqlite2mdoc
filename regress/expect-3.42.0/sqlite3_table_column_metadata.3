.Dt SQLITE3_TABLE_COLUMN_METADATA 3
.Os
.Sh NAME
.Nm sqlite3_table_column_metadata
.Nd extract metadata about a column of a table
.Sh SYNOPSIS
.In sqlite3.h
.Ft int
.Fo sqlite3_table_column_metadata
.Fa "sqlite3 *db"
.Fa "const char *zDbName"
.Fa "const char *zTableName"
.Fa "const char *zColumnName"
.Fa "char const **pzDataType"
.Fa "char const **pzCollSeq"
.Fa "int *pNotNull"
.Fa "int *pPrimaryKey"
.Fa "int *pAutoinc"
.Fc
.Sh DESCRIPTION
The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information
about column C of table T in database D on database connection
X.
The sqlite3_table_column_metadata() interface returns SQLITE_OK and
fills in the non-NULL pointers in the final five arguments with appropriate
values if the specified column exists.
The sqlite3_table_column_metadata() interface returns SQLITE_ERROR
if the specified column does not exist.
If the column-name parameter to sqlite3_table_column_metadata() is
a NULL pointer, then this routine simply checks for the existence of
the table and returns SQLITE_OK if the table exists and SQLITE_ERROR
if it does not.
If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...)
is NULL then the result is undefined behavior.
.Pp
The column is identified by the second, third and fourth parameters
to this function.
The second parameter is either the name of the database (i.e. "main",
"temp", or an attached database) containing the specified table or
NULL.
If it is NULL, then all attached databases are searched for the table
using the same algorithm used by the database engine to resolve unqualified
table references.
.Pp
The third and fourth parameters to this function are the table and
column name of the desired column, respectively.
.Pp
Metadata is returned by writing to the memory locations passed as the
5th and subsequent parameters to this function.
Any of these arguments may be NULL, in which case the corresponding
element of metadata is omitted.
.Bd -ragged
.TS
l l l.
T{
Parameter
T}	T{
Output Type
T}	T{
Description
T}
T{
5th
T}	T{
const char*
T}	T{
Data type
T}
T{
6th
T}	T{
const char*
T}	T{
Name of default collation sequence
T}
T{
7th
T}	T{
int
T}	T{
True if column has a NOT NULL constraint
T}
T{
8th
T}	T{
int
T}	T{
True if column is part of the PRIMARY KEY
T}
T{
9th
T}	T{
int
T}	T{
True if column is AUTOINCREMENT
T}
.TE
.Ed
.Pp
The memory pointed to by the character pointers returned for the declaration
type and collation sequence is valid until the next call to any SQLite
API function.
.Pp
If the specified table is actually a view, an error code
is returned.
.Pp
If the specified column is "rowid", "oid" or "_rowid_" and the table
is not a WITHOUT ROWID table and an INTEGER PRIMARY KEY
column has been explicitly declared, then the output parameters are
set for the explicitly declared column.
If there is no INTEGER PRIMARY KEY column, then
the outputs for the rowid are set as follows:
.Bd -literal
data type: "INTEGER" collation sequence: "BINARY" not null: 0 primary
key: 1 auto increment: 0
.Ed
.Pp
This function causes all database schemas to be read from disk and
parsed, if that has not already been done, and returns an error if
any errors are encountered while loading the schema.
.Sh IMPLEMENTATION NOTES
These declarations were extracted from the
interface documentation at line 6893.
.Bd -literal
SQLITE_API int sqlite3_table_column_metadata(
  sqlite3 *db,                /* Connection handle */
  const char *zDbName,        /* Database name or NULL */
  const char *zTableName,     /* Table name */
  const char *zColumnName,    /* Column name */
  char const **pzDataType,    /* OUTPUT: Declared data type */
  char const **pzCollSeq,     /* OUTPUT: Collation sequence name */
  int *pNotNull,              /* OUTPUT: True if NOT NULL constraint exists */
  int *pPrimaryKey,           /* OUTPUT: True if column part of PK */
  int *pAutoinc               /* OUTPUT: True if column is auto-increment */
);
.Ed
.Sh SEE ALSO
.Xr sqlite3 3
